// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/ 
// Â© https://github.com/bouchane-a 

//@version=6 
// Declares the script as an indicator, setting its name and overlay property.
indicator("Pine Script Strategy Screener", overlay = true) 

// Initializes a table panel at the bottom right of the chart to display strategy results. 
// It has 3 columns and 1 row, with specific colors and borders.
var table panel = table.new(position.bottom_right,3,1,color.rgb(0, 0, 0),color.yellow,1,color.yellow,1,false) 

// Defines variables for styling the table text. 
var size=size.normal 
var color_=color.yellow 
var width_=20 
var height_=0 
var font_=font.family_monospace 

// Defines a custom data type `STRATEGY` to hold information for each trading symbol. 
type STRATEGY 
	string symbol_name="" // Name of the trading symbol (e.g., "BTCUSDT"). 
	int bar_time=0 // Timestamp of the current bar. 
	bool new_bar=false // Flag to indicate if a new bar has started. 
	int bar_state_event=0 // Represents if the current bar is bullish (1) or bearish (-1). 
	int bar_laststate=0 // Stores the bar_state_event of the previous valid bar. 
	int bar_pstate=0 // Stores the bar_state of the previous bar. 
	int bar_state=0 // Current bar state based on bar_laststate. 
	int strategy_event=0 // Event generated by the strategy (e.g., 1 for bullish sequence, -1 for bearish sequence). 
//

// Constructor function to create a new STRATEGY object. 
new_STRATEGY(string symbol_="")=> 
    STRATEGY.new(symbol_name=symbol_) 
//

// Method `Run` associated with the STRATEGY type to process bar data and update strategy events. 
method Run(STRATEGY x, open_, high_, low_, close_, current_time) => 
	
	x.new_bar := false // Resets the new_bar flag at the beginning of each run. 
	
	// Checks if the current_time is valid and different from the stored bar_time, indicating a new bar. 
	if current_time != 0 and current_time != x.bar_time 
		x.bar_time := current_time // Updates the bar_time to the current time. 
		x.new_bar := true // Sets the new_bar flag to true. 
	//
	
	if x.new_bar // Executes the following logic only if a new bar has formed. 
		
		x.bar_state_event := 0 // Resets the bar state event. 
		x.strategy_event := 0 // Resets the strategy event. 
        
        // Determines if the bar is bullish (close > open) or bearish (close < open). 
        if close_ > open_ 
            x.bar_state_event := 1 // Sets bar_state_event to 1 for a bullish bar. 
        if close_ < open_ 
            x.bar_state_event := -1 // Sets bar_state_event to -1 for a bearish bar. 
        
        // Updates the last valid bar state. 
        if x.bar_state_event != 0 
            x.bar_laststate := x.bar_state_event 
        x.bar_pstate := x.bar_state // Stores the current bar state as the previous bar state. 
        x.bar_state := x.bar_laststate // Updates the current bar state. 
        
        // The following part checks whether a bullish bar comes directly after a bearish bar or the opposite. 
        if x.bar_state == 1 // If the current bar is bullish. 
            if x.bar_pstate == -1 // And the previous bar was bearish. 
                x.strategy_event := 1 // Sets strategy_event to 1 (bullish signal). 
        if x.bar_state == -1 // If the current bar is bearish. 
            if x.bar_pstate == 1 // And the previous bar was bullish. 
                x.strategy_event := -1 // Sets strategy_event to -1 (bearish signal). 
//

// Function to define the data points requested from security calls (open, high, low, close, time of the previous bar). 
request_expression() => 
    [open[1],high[1],low[1],close[1],time[1]] 
//

// Declares an array to hold STRATEGY objects for each symbol. 
var strategies = array.new<STRATEGY>() 

// Defines an array of cryptocurrency symbols to screen. 
var symbols = array.from("BTCUSDT","ETHUSDT","LTCUSDT","XRPUSDT","BCHUSDT","SOLUSDT","ADAUSDT","ATOMUSDT","AVAXUSDT","DOGEUSDT","DOTUSDT","BONKUSDT","LINKUSDT","SANDUSDT","TRXUSDT") 

// Initializes the `strategies` array with new STRATEGY objects for each symbol only on the first bar. 
if( barstate.isfirst ) 
	for i = array.size(symbols)-1 to 0 
		strategies.insert(0,new_STRATEGY(symbols.get(i))) 
//

// Fetches historical bar data for each symbol using `request.security`. 
// "BINANCE:SYMBOL" specifies the exchange and symbol.
// "1" indicates a 1-minute timeframe.
// `request_expression()` defines what data points to fetch (previous bar's OHLC and time).
// `barmerge.gaps_off` and `barmerge.lookahead_on` handle data gaps and lookahead.
[open_1, high_1, low_1, close_1, time_1] = request.security("BINANCE:BTCUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_2, high_2, low_2, close_2, time_2] = request.security("BINANCE:ETHUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_3, high_3, low_3, close_3, time_3] = request.security("BINANCE:LTCUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_4, high_4, low_4, close_4, time_4] = request.security("BINANCE:XRPUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_5, high_5, low_5, close_5, time_5] = request.security("BINANCE:BCHUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_6, high_6, low_6, close_6, time_6] = request.security("BINANCE:SOLUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_7, high_7, low_7, close_7, time_7] = request.security("BINANCE:ADAUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_8, high_8, low_8, close_8, time_8] = request.security("BINANCE:ATOMUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_9, high_9, low_9, close_9, time_9] = request.security("BINANCE:AVAXUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_10, high_10, low_10, close_10, time_10] = request.security("BINANCE:DOGEUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_11, high_11, low_11, close_11, time_11] = request.security("BINANCE:DOTUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_12, high_12, low_12, close_12, time_12] = request.security("BINANCE:BONKUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_13, high_13, low_13, close_13, time_13] = request.security("BINANCE:LINKUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_14, high_14, low_14, close_14, time_14] = request.security("BINANCE:SANDUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 
[open_15, high_15, low_15, close_15, time_15] = request.security("BINANCE:TRXUSDT","1",request_expression(),barmerge.gaps_off,barmerge.lookahead_on) 


// Runs the `Run` method for each STRATEGY object with its corresponding fetched market data. 
strategies.get(0).Run(open_1, high_1, low_1, close_1, time_1) 
strategies.get(1).Run(open_2, high_2, low_2, close_2, time_2) 
strategies.get(2).Run(open_3, high_3, low_3, close_3, time_3) 
strategies.get(3).Run(open_4, high_4, low_4, close_4, time_4) 
strategies.get(4).Run(open_5, high_5, low_5, close_5, time_5) 
strategies.get(5).Run(open_6, high_6, low_6, close_6, time_6) 
strategies.get(6).Run(open_7, high_7, low_7, close_7, time_7) 
strategies.get(7).Run(open_8, high_8, low_8, close_8, time_8) 
strategies.get(8).Run(open_9, high_9, low_9, close_9, time_9) 
strategies.get(9).Run(open_10, high_10, low_10, close_10, time_10) 
strategies.get(10).Run(open_11, high_11, low_11, close_11, time_11) 
strategies.get(11).Run(open_12, high_12, low_12, close_12, time_12) 
strategies.get(12).Run(open_13, high_13, low_13, close_13, time_13) 
strategies.get(13).Run(open_14, high_14, low_14, close_14, time_14) 
strategies.get(14).Run(open_15, high_15, low_15, close_15, time_15) 


// Function to find the maximum `bar_time` among all strategies. 
maxValue(STRATEGY[] a) => 
	max = a.get(0).bar_time 
	for i = 1 to array.size(a)-1 
		if ( a.get(i).bar_time > max ) 
			max := a.get(i).bar_time 
	max 
//

// Function to find the minimum `bar_time` among all strategies. 
minValue(STRATEGY[] a) => 
	min = a.get(0).bar_time 
	for i = 1 to array.size(a)-1 
		if ( a.get(i).bar_time < min ) 
			min := a.get(i).bar_time 
	min 
//

// Initializes strings to hold updated information for display in the table. 
update_symbols = "\n" 
update_bar_ts = "\n" 
update_text = "\n" 

// Checks if all symbols are on the same bar (i.e., their bar_times are identical). 
if( maxValue(strategies) == minValue(strategies) ) 
	// Iterates through each strategy to gather and format its results. 
	for i = 0 to array.size(strategies)-1 
		// If a strategy event (bullish or bearish bar sequence) occurred. 
		if ( strategies.get(i).strategy_event == 1 or strategies.get(i).strategy_event == -1 ) 
            if ( strategies.get(i).strategy_event == 1 ) // If it was a bullish event. 
                update_symbols += strategies.get(i).symbol_name+"\n" // Add symbol name. 
                update_bar_ts += str.format_time(strategies.get(i).bar_time,"yyyy-MM-dd' 'HH:mm:ss")+"\n" // Add formatted bar timestamp. 
                update_text += "Bullish Bar\n"  // Add "Bullish Bar" text.
            if ( strategies.get(i).strategy_event == -1 ) // If it was a bearish event. 
                update_symbols += strategies.get(i).symbol_name+"\n" // Add symbol name. 
                update_bar_ts += str.format_time(strategies.get(i).bar_time,"yyyy-MM-dd' 'HH:mm:ss")+"\n" // Add formatted bar timestamp. 
                update_text += "Bearish Bar\n"  // Add "Bearish Bar" text.
        else // If no specific strategy event occurred. 
            update_symbols += strategies.get(i).symbol_name+"\n" // Add symbol name. 
            update_bar_ts += str.format_time(strategies.get(i).bar_time,"yyyy-MM-dd' 'HH:mm:ss")+"\n" // Add formatted bar timestamp. 
            update_text += "-\n" // Add a dash to indicate no event. 
		//
	// Updates the table cells with the gathered information. 
	table.cell(panel, 0, 0, update_symbols, text_color=color_, text_size = size, width = 10, height = height_, text_font_family = font_) 
    table.cell(panel, 1, 0, update_bar_ts, text_color=color_, text_size = size, width = 18, height = height_, text_font_family = font_) 
    table.cell(panel, 2, 0, update_text, text_color=color_, text_size = size, width = 12, height = height_, text_font_family = font_) 
//